package rocho

import (
	"net/http"

	"golang.org/x/oauth2"
)

// OAuthStateManager manages OAuth2 state.
// State is kind of OAuth2 nonce.
// It's here to protect user from CSRF attacks.
type OAuthStateManager interface {
	InitializeState(w http.ResponseWriter, r *http.Request) (newState string, err error)
	ReadState(w http.ResponseWriter, r *http.Request) (state string, err error)
}

// OAuth2Handler uses OAuth2 in order to generate OAuth2AuthData.
// It also exposes appropriate HTTP handler functions.
//
// Due to nature of OAuth2, generated auth data is exposed for HTTP handler callback func, rather than by return value.
type OAuth2Handler struct {
	StateManager OAuthStateManager
	ErrorHandler func(w http.ResponseWriter, r *http.Request, err error)

	// AuthDataReceiver is responsible for taking AuthData and handling request depending on result.
	// It's user responsibility to implement this.
	// This function should probably redirect user to home on success and to some info on failure.
	AuthDataReceiver func(w http.ResponseWriter, r *http.Request, ad AuthData)

	OAuth2ServiceName string // used to identify OAuth2AuthData generated by this handler.
	OAuth2Config      *oauth2.Config
}

/*
// move to default implementation
func generateStateOauthCookie(w http.ResponseWriter) string {
	var expiration = time.Now().Add(20 * time.Minute)

	b := make([]byte, 16)
	rand.Read(b)
	state := base64.URLEncoding.EncodeToString(b)
	cookie := http.Cookie{Name: "oauthstate", Value: state, Expires: expiration}
	http.SetCookie(w, &cookie)

	return state
}
*/

// InitializeHandler creates handler, which is responsible for initializing OAuth2 flow and redirecting browser to 3rd party website.
func (handler *OAuth2Handler) InitializeHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		oauthState, err := handler.StateManager.InitializeState(w, r)
		if err != nil {
			handler.ErrorHandler(w, r, &OAuth2StateManagerError{err})
			return
		}

		url := handler.OAuth2Config.AuthCodeURL(oauthState)
		http.Redirect(w, r, url, http.StatusTemporaryRedirect)
	})
}

// CallbackHandler creates handler, which is responsible for handling OAuth2 flow going back from remote server.
// It's responsible for getting user's identifiers and creating token from it.
//
// Note: This function does token exchange.
// In order to replace HTTP client used by default replace context and it's value: oauth2.HTTPClient in HTTP request using middleware.
func (handler *OAuth2Handler) CallbackHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		oauthState, err := handler.StateManager.ReadState(w, r)
		if err != nil {
			handler.ErrorHandler(w, r, &OAuth2StateManagerError{err})
			return
		}

		// TODO(teawtihsand): constant time compare here?
		if r.FormValue("state") != oauthState {
			handler.ErrorHandler(w, r, &OAuth2StateError{})
			return
		}

		token, err := handler.OAuth2Config.Exchange(r.Context(), r.FormValue("code"))
		if err != nil {
			handler.ErrorHandler(w, r, &OAuth2TokenExchangeError{err})
			return
		}

		ad := OAuth2AuthData{
			Config:            handler.OAuth2Config,
			ExchangedToken:    token,
			OAuth2ServiceName: handler.OAuth2ServiceName,
		}

		handler.AuthDataReceiver(w, r, ad)
	})
}
